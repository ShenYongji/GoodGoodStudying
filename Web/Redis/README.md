SQL - Structured Query Language

比如：SQL Server, Oracle, MySQL

NoSQL - Not Only SQL 非关系型数据库

没有固定查询语言，键值对存储，列存储，文档存储

比如：MongoDB, Redis

特点：方便扩展，大数据量高性能，数据类型多样
<hr />

# Redis
Redis是一款内存高速缓存数据库。Redis全称为：Remote Dictionary Server（远程数据服务），使用C语言编写，单线程模型，操作都是原子的。Redis是一个key-value存储系统（键值存储系统 Hash Table），支持丰富的数据类型，比如字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。

### Redis特征
1. 速度快
2. 持久化： 数据保存在内存中，对数据进行异步更新。
    * RDB - Redis DataBase: 在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上
    * AOF - Append Only File: 将redis执行过的所有写指令记录下来，在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，实现数据恢复
    <br/>
    RDB vs AOF: 
    <br/>
    如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。缺点：对数据的完整性非常敏感，那么RDB方式就不太适合你，因为即使你每5分钟都持久化一次，当redis故障时，仍然会有近5分钟的数据丢失。
    <br/>
    AOF持久化策略是每秒钟fsync一次（fsync是指把缓存中的写指令记录到磁盘中），因为在这种情况下，redis仍然可以保持很好的处理性能，即使redis故障，也只会丢失最近1秒钟的数据
    <br>
    1、RDB需要定时持久化，风险是可能会丢两次持久之间的数据，量可能很大。
    2、AOF每秒fsync一次指令硬盘，如果硬盘IO慢，会阻塞父进程；风险是会丢失1秒多的数据；在Rewrite过程中，主进程把指令存到mem-buffer中，最后写盘时会阻塞主进程。
3. 多种数据结构
    1. Strings
    2. Hash Tables
    3. Linked Lists
    4. Sets
    5. Sorted Sets
4. 支持多种语言
5. 功能丰富
    1. 支持发布订阅
    2. 支持事务
    3. 支持Lua脚本
    4. Pipeline来提高客户端的并发效率
6. 简单
    1. 核心代码 230000行
    2. 不依赖外部库
    3. 单线程
7. 主从复制 实现了多个相同数据的 Redis 副本
8. 高可用，分布式
    1. 2.8支持高可用Redis-Sentinel
    2. 3.0支持分布式Redis-Cluster


### Redis好处与坏处

<b>好处</b>：
<br/>
将数据库数据存入缓存，请求直接从内存中取读不用经过数据库，减轻数据库压力并且提供性能。

<b>坏处</b>：
<br/>
数据不一致：缓存层的数据层有时间窗口不一致的问题
代码维护成本：本来实现SQL的逻辑，现在需要同时维护缓存的数据
内缓存可能会带来内存溢出的问题 (ehCache,loadingCache)

堆内缓存和远程服务器缓存redis的选择:
<br/>
堆内缓存一般性能更好，远程缓存需要套接字传输.用户级别缓存尽量采用堆内缓存,大数据量尽量采用远程缓存，服务节点化原则
<hr/>

### Redis的数据结构
Redis允许的key最大长度是512MB,value的最大长度也是512MB

1. String
2. List
3. Hash
4. Set
5. Sorted Set
6. Bitmap
7. HyperLogLog
<hr/>

### 热键 - Hot Key

热键 - 突然大量的请求去访问Redis上某个特定的key，导致流量集中，从而是Redis的服务器宕机。如果宕机之后会直接访问数据库。

1. 判断Hot Key
    <br/>
    1. 凭借业务经验，提前预估hot key
    <br/>
    比如商品秒杀时候，可以预判什么是Hot key
    2. 在客户端进行收集
    <br/>
    在操作Redis之前，加入数据统计的功能。
    3. 在proxy层做收集
    <br/>
    设置一个Proxy作为统一入口，在Proxy上统计
    4. 用Redis自带命令
    <br/>
    

<hr />

### Redis问题

1. 缓存穿透

    为了缓解数据库压力，在服务器和数据库之前加一层缓存
    
    正常情况：客户端发起请求，服务器处理，会从Redis缓存中查询客户端需要的请求数据，如果缓存中有，会将数据返回给服务器，服务器再返回给客户端。如果缓存中没有需要的数据，会从数据库查找，再返回给服务器
    
    缓存穿透是客户端查询一个数据，Redis缓存中没有，接着从数据库中请求，结果还是没有，于是请求失败。当用户很多，缓存没有命中，于是都去请求了数据库，此时对数据库造成很大压力。

    <b>解决方法</b>：
    
    1. 如果一个查询返回的数据为空，仍将这个空结果缓存，同时给他设计一个少于5分钟的过期时间。这样子第二次到缓存时就可以避免继续访问数据库
    2. 在缓存层加布隆过滤器(BloomFilter)将数据库中的 id ，通过某方式映射到布隆过滤器，当处理不存在的 id 时，布隆过滤器会将该请求过直接过滤出去，不会到数据库做操作。
    <br/>将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个bitmap 拦截掉，从而避免了对底层存储系统的查询压力
    <br />优势：优势占用内存空间很小，bit存储。性能特别高

2. 缓存击穿

    缓存击穿是指在高并发系统中，大量的请求同时查询一个key时，此时那个key正好失效，导致大量的请求直接想数据库请求。应对策略应该在业务数据分析和预防方面进行，配合缓存雪崩策略。

    通常表现：
    <br/>
    1. Redis中某个key过期
    2. 多个数据请求服务器，且均在缓存没有命中
    3. Redis在短时间内发起大量对数据中统一数据访问

    解决方案：

    1. 使用互斥锁 (mutex key): 只让一个线程进行，其他线程等待。(单机：synchronized或者lock，分布：memcache的add，redis的setnx)
    2. 永不过期：发现快要到期的时候，通过后台的异步线程进行缓存的构建
    3. 缓存屏障

3. 缓存雪崩

    缓存雪崩是指在某一段时间中，缓存集中过期失效，因此所有请求会直接对数据库请求，导致数据库的调用量暴增。由于原有缓存失效，新缓存未到期间，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机

    解决方案：
    <br/>
    1. Redis高可用(搭建集群)： Redis有可能失效，所以多设置几个Redis。这样一个Redis失效之后，其他的还可以工作。
    2. 限流降级：当缓存失效之后，通过加锁或者列队的形式来控制数据库的读取数量。比如只允许一个线程查询数据和写缓存，其他线程等待。
    3. 数据预热：在部署之前，把可能的数据预先访问一遍，使可能被大量访问的数据会加载到缓存中，在即将发生大并发访问前手动触发加载缓存，设置不同的过期时间，让缓存失效的时间点均匀

    * 缓存预热
    <br/>
    缓存预热是系统启动前，将相关缓存数据直接加载到缓存系统中。这样可以避免用户请求时，先查数据库，再将数据缓存的问题
    准备工作：
    <br/>
    统计数据访问记录，统计高频数据。根据级别，Redis优先加载级别高的数据。通过分布式多服务器同时进行数据读取，加速数据加载过程。

    * 缓存降级
    <br/>
    一般指缓存失效或者缓存服务挂掉的情况下，不去访问数据库。直接访问内部部分数据缓存或者直接返回默认数据。








<br/>
<br/>
<br/>
<br/>
<br/>
<hr/>
参考
<br/>
<a href="https://www.huaweicloud.com/articles/131a97b08416012d4e43778ca40c4160.html" >redis缓存 面试总结</a>
<br/>
<a href="https://www.163.com/dy/article/G1GQEDKI053726TL.html" >Redis缓存解决方案</a>
<br/>
<a href="https://www.jianshu.com/p/dc7296d73ef7" >Redis特性</a>
